using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections;

public class InDungeonState : PlayerStateInterface
{
    private readonly Player player;
    private Coroutine jumpCoroutine;
    private float JUMP_MOVEMENT_PENALTY = 0.3f;

    // 애니메이션 파라미터 해시 (성능 최적화)
    private readonly int isWalkingHash = Animator.StringToHash("isWalking");
    private readonly int isRunningHash = Animator.StringToHash("isRunning");
    private readonly int isGroundedHash = Animator.StringToHash("isGrounded");
    private readonly int jumpHash = Animator.StringToHash("jump");
    private readonly int yVelocityHash = Animator.StringToHash("yVelocity");

    public InDungeonState(Player player)
    {
        this.player = player ?? throw new System.ArgumentNullException(nameof(player));
    }

    public void Enter()
    {
        Debug.Log("던전 상태에 진입");
        player.anim.Play("Idle_Dungeon");
        player.isRunning = false;

        // 필요한 이벤트에 메서드를 구독
        player.inputActions.Player.Run.performed += OnRunPerformed;
        player.inputActions.Player.Move.canceled += OnMoveCanceled;
    }

    public void Update()
    {
        // 점프 입력 처리
        if (player.inputActions.Player.Jump.WasPressedThisFrame())
        {
            if (player.isGrounded && !player.isJumping)
            {
                jumpCoroutine = player.StartCoroutineFromState(JumpRoutine());
            }
        }

        // 이동 입력 처리
        Vector2 moveInput = player.inputActions.Player.Move.ReadValue<Vector2>();
        player.moveInput = moveInput;
        bool isMoving = moveInput.magnitude > 0;

        // 애니메이터 로직
        player.anim.SetBool(isWalkingHash, isMoving && !player.isRunning);
        player.anim.SetBool(isRunningHash, isMoving && player.isRunning);

        // 캐릭터 방향 전환
        if (!player.isJumping)
        {
            if (player.moveInput.x != 0)
            {
                player.transform.localScale = new Vector3(Mathf.Sign(player.moveInput.x), 1f, 1f);
            }
        }
    }

    public void FixedUpdate()
    {
        // 현재 상태에 맞는 속도를 선택
        float currentSpeed = player.isRunning ? player.runSpeed : player.walkSpeed;
        Vector2 finalVelocity = player.moveInput.normalized * currentSpeed;

        // 점프 중에는 Y축 이동이 다소 힘들어짐
        if (player.isJumping)
        {
            finalVelocity.y *= JUMP_MOVEMENT_PENALTY;
        }

        player.rb.linearVelocity = finalVelocity;
    }
    public void Exit()
    {
        Debug.Log("던전 상태를 벗어남");
        player.isRunning = false;
        player.inputActions.Player.Run.performed -= OnRunPerformed;
        player.inputActions.Player.Move.canceled -= OnMoveCanceled;

        // 상태를 나갈 때, 만약 점프 중이었다면 코루틴을 중지시켜
        // 다른 상태에서 점프가 계속되는 현상을 방지
        if (jumpCoroutine != null)
        {
            player.StopCoroutine(jumpCoroutine);
            // 점프 상태 강제 종료
            player.isJumping = false;
            player.isGrounded = true;
            player.playerGround.enabled = true;
        }
        // 다음 상태로 가기 전, 걷기/달리기 애니메이션 상태를 초기화
        player.anim.SetBool(isWalkingHash, false);
        player.anim.SetBool(isRunningHash, false);
    }

    // Run 액션이 'performed' 될 때 호출될 메서드
    private void OnRunPerformed(InputAction.CallbackContext context)
    {
        // 더블 탭 성공 - 달리기 상태로 전환
        // 점프 중에는 달릴 수 없음
        if (!player.isJumping)
        {
            player.isRunning = true;
        }
    }

    // 이동 키에서 손을 떼면 달리기가 멈춤
    private void OnMoveCanceled(InputAction.CallbackContext context)
    {
        player.isRunning = false;
    }

    // --------------------- 점프 구현부 ------------------------
    private IEnumerator JumpRoutine()
    {
        // 점프 시작 처리
        player.isGrounded = false;
        player.isJumping = true;

        // PlayerGround 비활성화
        if (player.playerGround != null)
            player.playerGround.enabled = false;

        player.anim.SetBool(isGroundedHash, false);
        player.anim.SetTrigger(jumpHash);

        // 점프 중
        float elapsedTime = 0f;
        float jumpDuration = 1.0f;
        float jumpHeight = 3.0f;

        Vector3 startVisualPos = player.visualsTransform.localPosition;
        float previousHeight = 0f;

        while (elapsedTime < jumpDuration)
        {
            float currentHeight = Mathf.Sin((elapsedTime / jumpDuration) * Mathf.PI) * jumpHeight;
            player.visualsTransform.localPosition = new Vector3(startVisualPos.x, currentHeight, startVisualPos.z);
            
            float yVelocity = (currentHeight - previousHeight) / Time.deltaTime;
            player.anim.SetFloat(yVelocityHash, yVelocity);

            previousHeight = currentHeight;
            elapsedTime += Time.deltaTime;
            yield return null;
        }

        // 점프 완료 처리
        player.visualsTransform.localPosition = startVisualPos;

        if (player.playerGround != null)
            player.playerGround.enabled = true;

        player.isJumping = false;
        player.isGrounded = true;
        player.isRunning = false;

        player.anim.SetBool(isGroundedHash, true);
        player.anim.SetFloat(yVelocityHash, 0);

        jumpCoroutine = null;
    }
}